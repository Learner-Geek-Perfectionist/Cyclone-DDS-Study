# 📝 学习会话记录

> 日期：2026-02-06  
> 会话编号：session-11  
> 时长：约 45 分钟

---

## 🎯 本次目标

- [x] 深入 `ddsi_radmin.c` 源码，理解 rbuf/rmsg/rdata 的完整初始化流程
- [x] 理解 `ddsi_rdata_new` 的创建过程和三种使用场景
- [x] 理解 rbuf 图 (data path - rbuf.svg) 中每个元素对应的代码结构
- [x] 彻底搞清 zoff/off 转换宏的设计意图

---

## 📚 学习主题

### 主题 1：rbuf 图与代码结构的完整对应

#### 核心概念

通过阅读 `cyclonedds/docs/dev/data path - rbuf.svg` 并逐一定位源码，建立了图中所有元素到代码的映射：

| 图中元素 | 对应代码 | 所在文件 |
|----------|----------|----------|
| rbuf header | `struct ddsi_rbuf` | `ddsi_radmin.c:403` |
| rmsg | `struct ddsi_rmsg` | `ddsi_radmin.h:53` |
| chunk hdr | `struct ddsi_rmsg_chunk` | `ddsi_radmin.h:34` |
| raw packet | `DDSI_RMSG_PAYLOAD(rmsg)` 指向的区域 | `ddsi_radmin.h:94` |
| ddsi receiver state | `struct ddsi_receiver_state` | `ddsi__radmin.h:52` |
| sampleinfo | `struct ddsi_rsample_info` | `ddsi__radmin.h:65` |
| rdata | `struct ddsi_rdata` | `ddsi_radmin.h:98` |
| defrag admin | `struct ddsi_defrag` | `ddsi_radmin.c` |
| reorder admin | `struct ddsi_reorder` | `ddsi_radmin.c` |

#### 理解要点

- 图中灰色区域表示 rbuf 的 `raw[]` 柔性数组，所有数据（原始报文 + 派生元数据）都紧凑排列在其中
- receiver_state、sampleinfo、rdata 都通过 `ddsi_rmsg_alloc` 从 chunk 中 bump 分配，不单独 malloc
- 图中右侧的额外 chunk 通过 `lastchunk->next` 串联，当首个 chunk 空间不足时动态分配

---

### 主题 2：struct ddsi_rbuf 逐字段解析

#### 核心概念

```c
struct ddsi_rbuf {
  ddsrt_atomic_uint32_t n_live_rmsg_chunks;  // 引用计数，追踪活跃 chunk 数
  uint32_t size;                              // raw[] 的字节数（总容量）
  uint32_t max_rmsg_size;                     // 单次 rmsg 分配的最大尺寸
  struct ddsi_rbufpool *rbufpool;              // 回指所属池子
  bool trace;                                  // 调试日志开关

  unsigned char *freeptr;   // 碰撞指针（bump pointer），指向下一个可分配位置

  union {                   // 对齐填充，确保 raw[] 起始地址 8 字节对齐
    int64_t l;
    double d;
    void *p;
  } u;

  unsigned char raw[];      // C99 柔性数组，实际存储空间
};
```

关键设计：
1. **`freeptr = rb->raw`** — 初始化时指向 raw 起点，顺序分配（bump allocator）
2. **`union u` 纯粹是对齐填充** — 自身不被读写，保证 `raw[]` 在 8 字节边界上
3. **`n_live_rmsg_chunks` 用原子类型** — 因为释放可能发生在任意线程
4. **`raw[]` 不做内容初始化** — 网络报文由内核 recv() 直接覆盖，派生数据逐字段赋值

---

### 主题 3：rbufpool → rbuf → rmsg 三层分配链

#### 核心概念

```
ddsi_rbufpool_new()
  └─ ddsi_rbuf_alloc_new()           ← malloc(sizeof(rbuf) + size)
       rb->freeptr = rb->raw          ← 指向空白区域起点

ddsi_rmsg_new()  (每次收包前)
  └─ ddsi_rbuf_alloc()
       检查 freeptr 处是否有足够空间
       │ 不够 → ddsi_rbuf_new() → 分配新 rbuf 替换 current
       │ 够   → return rb->freeptr   ← rmsg 坐落在此
       └─ 初始化 rmsg 字段 (refcount, chunk, lastchunk)

收包: recv() 写入 DDSI_RMSG_PAYLOAD(rmsg)

处理报文时:
  ddsi_rmsg_alloc() → 从 chunk 中顺序分配 receiver_state, sampleinfo, rdata

ddsi_rmsg_commit()
  └─ freeptr 推进到已用空间之后   ← 此时才"确认"占用
```

**关键洞见**：`freeptr` 在 `commit()` 时才推进，不在分配时推进。如果报文处理失败或被丢弃，直接不 commit，空间自动回收，零成本。

---

### 主题 4：ddsi_rdata_new 的三种使用场景

#### 核心概念

```c
struct ddsi_rdata *ddsi_rdata_new (struct ddsi_rmsg *rmsg,
    uint32_t start, uint32_t endp1,
    uint32_t submsg_offset, uint32_t payload_offset, uint32_t keyhash_offset)
{
  struct ddsi_rdata *d;
  if ((d = ddsi_rmsg_alloc (rmsg, sizeof (*d))) == NULL)  // 从 chunk 中 bump 分配
    return NULL;
  d->rmsg = rmsg;
  d->nextfrag = NULL;
  d->min = start;
  d->maxp1 = endp1;
  d->submsg_zoff = (uint16_t) DDSI_OFF_TO_ZOFF (submsg_offset);
  d->payload_zoff = (uint16_t) DDSI_OFF_TO_ZOFF (payload_offset);
  d->keyhash_zoff = (uint16_t) DDSI_OFF_TO_ZOFF (keyhash_offset);
  return d;
}
```

三种调用场景：

| 场景 | min | maxp1 | 说明 |
|------|-----|-------|------|
| 完整数据 (Data) | 0 | sampleinfo->size | 覆盖整个样本 |
| 分片数据 (DataFrag) | begin | endp1 | 只覆盖样本的一部分 |
| 空洞 (Gap) | 0 | 0 | 长度为 0 的特殊标记 |

---

### 主题 5：zoff/off 转换宏的完整理解

#### 核心概念

`zoff` = 存储在 rdata 字段中的紧凑格式（`uint16_t`）  
`off` = 外部使用的真实偏移量（`unsigned`/`uint32_t`）

```c
// 存入时：uint32_t → uint16_t
#define DDSI_OFF_TO_ZOFF(off)  ((unsigned short)(off))

// 读出时：uint16_t → unsigned
#define DDSI_ZOFF_TO_OFF(zoff) ((unsigned)(zoff))
```

**宏的双重作用**：

1. **消除类型警告**（现在就在起作用）：`uint16_t` 参与 `size_t` 等运算时，显式转 `unsigned` 避免编译器隐式转换警告

2. **预留编码变更空间**（未来可能用到）：如果将来改为压缩存储（利用 4 字节对齐，除以 4 存储），只需修改这两个宏定义，所有使用方代码不受影响

#### 为什么 `uint16_t` 就够用？

UDP 报文最大 64KB = 65535 字节，`uint16_t` 范围 0~65535，刚好覆盖。用 `uint32_t` 高 16 位永远是 0，浪费空间。rdata 是高频分配对象，每个省 6 字节（3 字段 × 2 字节）意义显著。

#### 14 bit 压缩的可能性

RTPS 中偏移量总是 4 字节对齐（0, 4, 8, 12, ...），低 2 位永远是 00。如果除以 4 存储，14 bit 可表示 `16383 × 4 = 65532`，覆盖 64KB。省出的 6 bit（3 字段 × 2 bit）可用 C 位域分配给新字段。

---

## 💡 心得体会

- bump allocator 是一种极简高效的分配策略：顺序分配、不复用已释放空间、commit 时才确认。代价是可能有内部碎片，但在接收路径这种"分配-处理-释放"的短生命周期场景下非常合适
- Cyclone DDS 作者对 C 语言底层技巧运用娴熟：柔性数组、union 对齐填充、逗号表达式 assert、宏抽象编码层——都是实用而非炫技
- 阅读系统级 C 代码时，注释往往比代码更有价值。`ddsi_radmin.c` 的注释详细解释了设计决策和未来可能的变更方向

---

## ❓ 遗留问题

1. ~~`ddsi_radmin.c` 中 `ddsi_rmsg_new` 的完整分配流程~~ ✅ 已学习
2. defrag（分片重组）的 interval tree 实现细节
3. reorder（重排序）如何按序列号排序乱序样本
4. rbuf 的 bump allocator 不复用已释放空间，实际运行中碎片化问题严重吗？

---

## 📖 参考资料

- 源码：`cyclonedds/src/core/ddsi/include/dds/ddsi/ddsi_radmin.h`（公开头文件）
- 源码：`cyclonedds/src/core/ddsi/src/ddsi__radmin.h`（内部头文件，含 receiver_state/rsample_info 定义）
- 源码：`cyclonedds/src/core/ddsi/src/ddsi_radmin.c`（rbuf/rmsg/rdata 实现）
- 源码：`cyclonedds/src/core/ddsi/src/ddsi_receive.c`（rdata_new 的调用现场）
- 图表：`cyclonedds/docs/dev/data path - rbuf.svg`（rbuf 内存布局图）

---

## 🎯 下次目标

- [ ] 深入 defrag（分片重组）实现：interval tree、nextfrag 链构建
- [ ] 深入 reorder（重排序）实现：序列号排序、sample chain 输出
- [ ] 理解 ddsi_rmsg_commit / ddsi_rmsg_free 的引用计数管理

---

## 📊 进度更新

| 模块 | 之前 | 之后 |
|------|------|------|
| radmin 源码（rbuf/rmsg/rdata） | 🔄 | ✅ |
| defrag/reorder | ❓ | ❓（下次目标） |
