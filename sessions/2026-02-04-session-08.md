# 📝 学习会话记录

> 日期：2026-02-04  
> 会话编号：session-08  
> 时长：约 60 分钟

---

## 🎯 本次目标

- [x] 深入理解 DDS Security 插件组件架构
- [x] 学习 MPT 多进程测试框架
- [x] 学习 rbuf 接收缓冲区数据结构

---

## 📚 学习主题

### 主题 1：DDS Security 插件组件架构

#### 核心概念

通过 `dds_security_plugin_components.png` 深入理解安全插件架构：

1. **三大核心插件**：
   - **Authentication**：身份验证，产生 IdentityHandle 和 SharedSecretHandle
   - **AccessControl**：访问控制，产生 PermissionsHandle
   - **Cryptographic**：加密/解密，使用 PermissionsHandle 和 SharedSecretHandle

2. **Token vs Handle**：
   - **Token**（IdentityToken、PermissionsToken、CryptoToken）：通过网络发送给远程参与者
   - **Handle**：本地引用，在插件之间传递

3. **Diffie-Hellman 密钥交换**：
   - 双方交换公钥（A = g^a, B = g^b）
   - 各自计算共享密钥 S = g^(ab)
   - S 被封装成 SharedSecretHandle，传递给 Crypto 插件派生 AES 密钥

4. **安全检查链**：
   ```
   Authentication → AccessControl → Cryptographic
        │                │                │
   "你是谁？"      "你能做什么？"    "怎么保护数据？"
        │                │                │
   IdentityHandle ──use──▶ PermissionsHandle ──use──▶ 加密策略
   ```

#### 理解要点

- Token 的使用者是远程参与者（图中只显示本地组件）
- Handle 传递遵循最小权限原则：每个插件只拿到需要的信息
- SharedSecretHandle 是密钥交换的结果，用于派生对称加密密钥

---

### 主题 2：MPT 多进程测试框架

#### 核心概念

通过 `mpt_flow.png` 和 `mpt_tree.png` 学习 MPT 框架：

1. **三层结构**：
   - **Suite**：测试套件（如 communication, security）
   - **Test**：测试场景（如 basic_pubsub）
   - **Process**：进程角色（如 publisher, subscriber）

2. **两种运行模式**：
   - **主运行器模式**（process requested = no）：遍历所有测试，启动子进程
   - **子进程模式**（process requested = yes）：执行实际测试代码

3. **图例颜色含义**：
   - 白色：Runner code
   - 蓝色：CMake 生成的注册代码
   - 绿色：MPT_TestProcess 宏
   - 黄色：MPT_ProcessEntry 宏

#### 代码示例

```c
/*
 * 📌 示例：MPT 多进程测试
 * 🎯 目标：理解如何定义多进程测试
 */

// Publisher 进程
MPT_TestProcess(communication, basic_pubsub, publisher) {
    // 创建 publisher，发送数据
    dds_write(writer, &msg);
}

// Subscriber 进程
MPT_TestProcess(communication, basic_pubsub, subscriber) {
    // 创建 subscriber，接收数据
    dds_take(reader, &msg);
    MPT_ASSERT(msg.value == expected);
}
```

---

### 主题 3：rbuf 接收缓冲区数据结构

#### 核心概念

通过 `data path - rbuf.svg` 深入理解接收端数据结构：

1. **层级结构**：
   ```
   rbuf (Receive Buffer)
     └── rmsg (Receive Message)
           └── chunk(s) (数据块)
                 └── rdata (数据引用)
   ```

2. **关键数据结构**：
   - **rbuf**：预分配的大块内存池
   - **rmsg**：表示一个原始数据包 + 派生数据，含引用计数
   - **chunk**：固定大小的分配单元，通过 chunk hdr 链接
   - **rdata**：零拷贝数据引用（offset + length）
   - **sampleinfo**：样本元数据（时间戳、源地址等）

3. **零拷贝设计**：
   ```
   rdata
     ├── rmsg*         → 引用 rmsg（生命周期管理）
     ├── offset        → 数据起始偏移
     └── length        → 数据长度
   ```
   rdata 不复制数据，只存储引用！

4. **只有 DATA/DATA_FRAG 创建 rdata**：
   - 控制消息（HEARTBEAT、ACKNACK 等）直接处理，不创建 rdata
   - 只有携带用户数据的子消息才需要 rdata

5. **分片与重排序**：
   - **defrag**：使用区间树管理分片重组
   - **reorder**：使用区间树处理乱序样本
   - **fragchain**：链接分片的 rdata

#### 理解要点

- chunk 是固定大小的（> 最大包尺寸），便于管理
- 最后一个 chunk 尽量小，减少内存浪费
- lastchunk 指针用于快速定位最后一个 chunk
- 引用计数归零时 rmsg 被回收，释放 rbuf 空间

---

### 主题 4：异步写入与 Latency Budget

#### 核心概念

通过 `async_write.md` 学习异步写入：

1. **Latency Budget QoS**：
   - 字面意思：延迟预算/延迟容忍度
   - = 0：不容忍延迟，必须立即发送（同步）
   - > 0：可以容忍延迟，允许优化（异步）

2. **同步 vs 异步**：
   ```
   同步：dds_write() → 序列化 → 打包 → 发送 → 返回
   异步：dds_write() → 序列化 → 入队 → 返回（sendq 线程后台发送）
   ```

---

## 💡 心得体会

1. **DDS Security 设计精妙**：Token 用于网络传输，Handle 用于本地引用，安全检查链体现了职责分离和最小权限原则。

2. **零拷贝是高性能关键**：rdata 只存储 offset + length，避免数据复制，这对高吞吐量场景至关重要。

3. **引用计数管理生命周期**：rmsg 的引用计数由 rdata 维护，全部释放后才回收，这是一种优雅的内存管理方式。

4. **MPT 框架设计巧妙**：同一个可执行文件既能做主运行器又能做子进程，通过参数区分角色，便于测试多进程场景。

---

## ❓ 遗留问题

1. rbuf 的具体内存回收策略（是否支持中间回收还是只能 LIFO）
2. defrag 和 reorder 的区间树具体实现细节
3. 实际源码中 rdata、rmsg 的结构体定义

---

## 📖 参考资料

- 图片：`cyclonedds/docs/dev/pictures/dds_security_plugin_components.png`
- 图片：`cyclonedds/docs/dev/pictures/mpt_flow.png`
- 图片：`cyclonedds/docs/dev/pictures/mpt_tree.png`
- SVG：`cyclonedds/docs/dev/data path - rbuf.svg`
- 文档：`cyclonedds/docs/dev/async_write.md`

---

## 🎯 下次目标

- [ ] 学习 `data path - receive.svg` 完整接收路径
- [ ] 查看 rdata/rmsg 源码实现
- [ ] 学习 HelloWorld 示例，开始实践

---

## 📊 进度更新

| 模块 | 之前 | 之后 |
|------|------|------|
| DDS Security 插件 | 🔄 | ✅ |
| MPT 测试框架 | ❓ | ✅ |
| rbuf 接收缓冲区 | ❓ | ✅ |
| 核心数据结构 | ❓ | 🔄 |
