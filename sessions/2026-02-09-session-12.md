# 📝 学习会话记录

> 日期：2026-02-09  
> 会话编号：session-12  
> 时长：约 60 分钟

---

## 🎯 本次目标

- [x] 深入理解 rdata 的 min/maxp1 字段含义
- [x] 理解 submsg_zoff / payload_zoff 的物理坐标设计
- [x] 理解 rmsg 集中式引用计数机制（BIAS 设计）
- [x] 理解 freeptr 和 rbuf 的 bump allocator 内存管理
- [x] 理解 chunk 链表机制和 rbufpool 生命周期

---

## 📚 学习主题

### 主题 1：rdata 的 min/maxp1 — 样本字节偏移范围

#### 核心概念

1. **min/maxp1 表示左闭右开区间 [min, maxp1)**：rdata 覆盖的是完整样本 serialized payload 中第 min 到第 maxp1-1 字节
2. **字节偏移而非分片编号**：这样设计可以解耦分片大小，支持部分重叠的分片，简化重传时的灵活性
3. **非分片数据**：min=0, maxp1=sampleinfo->size，一个 rdata 覆盖完整 payload
4. **分片数据**：begin = (fragmentStartingNum - 1) * fragmentSize，endp1 由 fragmentSize × fragmentsInSubmessage 计算

#### 代码示例

```c
/*
 * 📌 示例：非分片 Data 的 rdata 创建
 * 🎯 目标：理解 min=0, maxp1=size 覆盖完整样本
 */
// ddsi_receive.c:2661
rdata = ddsi_rdata_new(rmsg, 0, sampleinfo->size, submsg_offset, payload_offset, keyhash_offset);

/*
 * 📌 示例：分片 DataFrag 的字节偏移计算
 * 🎯 目标：理解字节偏移如何从 RTPS 分片字段计算
 */
// ddsi_receive.c:2751-2770
begin = (msg->fragmentStartingNum - 1) * msg->fragmentSize;
endp1 = begin + (uint32_t) msg->fragmentSize * msg->fragmentsInSubmessage;
if (endp1 > msg->sampleSize)
    endp1 = msg->sampleSize;  // 最后一个分片可能不足整片
rdata = ddsi_rdata_new(rmsg, begin, endp1, submsg_offset, payload_offset, keyhash_offset);

/*
 * 📌 示例：defrag 中判断是否为分片
 * 🎯 目标：min==0 且 maxp1==size 说明是完整样本
 */
// ddsi_radmin.c:1274-1279
static int ddsi_rdata_is_fragment(const struct ddsi_rdata *rdata, const struct ddsi_rsample_info *sampleinfo)
{
    assert(rdata->min <= rdata->maxp1);
    assert(rdata->maxp1 <= sampleinfo->size);
    return !(rdata->min == 0 && rdata->maxp1 == sampleinfo->size);
}
```

#### 理解要点

- min/maxp1 描述的是 **serialized payload**（序列化载荷）的字节范围，不是整个 submessage
- 使用字节偏移的三个优势：解耦分片大小、天然支持重叠、简化重传
- defrag 区间树判断完成条件：根节点的 [min, maxp1) 覆盖 [0, sampleinfo->size)

---

### 主题 2：rdata 的双坐标系 — 物理位置 vs 逻辑位置

#### 核心概念

1. **submsg_zoff**：指向 submessage header（smhdr）在网络包中的起始偏移
2. **payload_zoff**：指向 serialized payload 在网络包中的起始偏移（跳过 header + inline QoS）
3. **物理坐标 vs 逻辑坐标**：zoff 系列定位"数据在网络包中的物理位置"，min/maxp1 定位"数据在完整样本中的逻辑位置"

#### 理解要点

- submsg_zoff 用于交付时回溯 submessage header，提取 writerId、readerId、inline QoS
- payload_zoff 用于反序列化时定位 CDR 数据起始
- 两套坐标各司其职，在 defrag 完成后的交付阶段都会被使用

---

### 主题 3：rmsg 集中式引用计数 — BIAS 机制

#### 核心概念

1. **rdata 没有独立引用计数**：所有 rdata 的引用都累加到 rmsg->refcount
2. **UNCOMMITTED_BIAS (2^31)**：rmsg 创建时设置，commit 时减去，作为处理期间的"锁"
3. **RDATA_BIAS (2^20)**：每个 rdata 进入 defrag 时加 2^20，允许后续用一次原子操作完成转换
4. **rmbias_and_adjust**：sub = RDATA_BIAS - adjust，一次原子减法同时"去 BIAS + 保留实际引用"

#### 代码示例

```c
/*
 * 📌 示例：refcount 的完整生命周期
 * 🎯 目标：理解 BIAS 机制如何减少原子操作次数
 */

// 1. 创建：refcount = 2^31
ddsrt_atomic_st32(&rmsg->refcount, RMSG_REFCOUNT_UNCOMMITTED_BIAS);

// 2. rdata 进入 defrag：refcount += 2^20
ddsrt_atomic_add32(&rmsg->refcount, RMSG_REFCOUNT_RDATA_BIAS);

// 3. commit：refcount -= 2^31
if (ddsrt_atomic_sub32_nv(&rmsg->refcount, RMSG_REFCOUNT_UNCOMMITTED_BIAS) == 0)
    ddsi_rmsg_free(rmsg);  // 没人引用，直接释放

// 4. rdata 完成 reorder，被 N 个 reader 引用：
//    一次原子操作：refcount -= (2^20 - N)
sub = RMSG_REFCOUNT_RDATA_BIAS - (uint32_t)adjust;
if (ddsrt_atomic_sub32_nv(&rmsg->refcount, sub) == 0)
    ddsi_rmsg_free(rmsg);

// 5. 每个 reader 交付完：refcount -= 1
if (ddsrt_atomic_dec32_ov(&rmsg->refcount) == 1)
    ddsi_rmsg_free(rmsg);
```

#### 理解要点

- 集中式引用计数避免了给每个 rdata 单独维护引用计数的开销
- RDATA_BIAS 允许推迟实际引用计数的结算到 reorder 完成后，减少原子操作次数
- rmsg 的释放可能发生在任何线程（接收线程 commit 时或交付线程 unref 时）

---

### 主题 4：freeptr 与 rbuf 的 bump allocator

#### 核心概念

1. **freeptr** 是 rbuf 中 raw[] 的"下一个可分配位置"指针
2. **分配时不推进**：ddsi_rbuf_alloc 返回 freeptr 但不动它
3. **commit 时才推进**：commit_rmsg_chunk 将 freeptr 推到 chunk 末尾
4. **refcount==0 时不推进**：freeptr 不动 = 内存原地复用 = 零开销丢弃

#### 理解要点

- rbuf 是 arena allocator（区域分配器），只进不退
- 已释放的 rmsg 产生的"空洞"不会被回收（作者承认这是设计取舍）
- rbuf 空间不够时直接分配新 rbuf 替换 current

---

### 主题 5：chunk 链表与 rbufpool 生命周期

#### 核心概念

1. **chunk 是 rbuf 的分配单位**：每个最大 max_rmsg_size 字节
2. **rmsg 拥有 chunk 链表**：第一个 chunk 内嵌在 rmsg 中，后续按需追加
3. **size vs max_rmsg_size**：size 是 rbuf 总容量，max_rmsg_size 是单 chunk 上限
4. **rbufpool 只跟踪一个 current rbuf**：旧 rbuf 靠 n_live_rmsg_chunks 引用计数自管理

#### 理解要点

- 同一 rmsg 的不同 chunk 可能在不同 rbuf 上（因为分配新 chunk 时 rbuf 可能已换新）
- rbufpool.current 是分配的唯一入口，旧 rbuf 完全脱离 pool 管理
- n_live_rmsg_chunks 归零时 rbuf 被 ddsrt_free

---

## 💡 心得体会

- radmin 的内存管理设计体现了"为高频路径优化"的思想：大多数 rmsg 在 commit 时 refcount==0 直接原地复用，这个快路径几乎零开销
- BIAS 引用计数机制巧妙地利用了一个 uint32 的位空间：高位做锁（UNCOMMITTED）、中间位做 rdata 追踪（RDATA_BIAS）、低位做细粒度引用
- 物理坐标（zoff）和逻辑坐标（min/maxp1）的分离设计值得学习，让 defrag 和交付各自关注自己需要的信息
- rbuf 的"空洞不回收"策略看似浪费，但在高吞吐场景下，简单的 bump allocator 比复杂的空闲链表管理更高效

---

## ❓ 遗留问题

1. defrag 的 AVL 区间树合并算法的具体实现细节
2. reorder 如何处理乱序样本的区间合并
3. delivery queue 的工作机制和线程模型
4. 发送路径（WHC → transmit → xmsg）的内存管理机制

---

## 📖 参考资料

- 源码：`cyclonedds/src/core/ddsi/include/dds/ddsi/ddsi_radmin.h` — rdata/rmsg/chunk 结构定义
- 源码：`cyclonedds/src/core/ddsi/src/ddsi_radmin.c` — rbuf/rmsg/rdata 完整实现
- 源码：`cyclonedds/src/core/ddsi/src/ddsi__radmin.h` — 内部接口（defrag/reorder/dqueue）
- 源码：`cyclonedds/src/core/ddsi/src/ddsi_receive.c` — 接收路径中 rdata 的创建
- 源码：`cyclonedds/src/core/ddsi/src/ddsi__protocol.h` — RTPS submessage 结构定义
- 源码：`cyclonedds/src/core/ddsi/src/ddsi_serdata_cdr.c` — 反序列化时使用 rdata 坐标

---

## 🎯 下次目标

- [ ] 深入 defrag 的 AVL 区间树实现：分片插入、区间合并、完成判定
- [ ] 深入 reorder 的乱序处理：区间合并、交付触发条件
- [ ] 理解 delivery queue（dqueue）的线程模型和交付流程
- [ ] 从 defrag → reorder → dqueue 完整追踪一个分片样本的接收流程

---

## 📊 进度更新

| 模块 | 之前 | 之后 |
|------|------|------|
| radmin 内存管理深入 | 🔄 | ✅ |
| 核心数据结构 (defrag/reorder) | 🔄 | 🔄（待深入） |
| 内存管理 | 🔄 | 🔄（接收路径 rbuf 全链路已掌握） |
