# 📝 学习会话记录

> 日期：2026-01-20  
> 会话编号：session-01  
> 时长：约 120 分钟

---

## 🎯 本次目标

- [x] 深入学习 DDS-RTPS 规范文档
- [x] 理解 RTPS 消息模块（Messages Module）
- [x] 理解 RTPS 子消息类型
- [x] 开始学习 RTPS 行为模块（Behavior Module）

---

## 📚 学习主题

### 主题 1：RTPS 子消息类型详解

#### 核心概念

1. **子消息分类**：
   - **Entity Submessages**：针对特定实体的消息（DATA, HEARTBEAT, ACKNACK 等）
   - **Interpreter Submessages**：修改 Receiver 状态，影响后续子消息解释（InfoTimestamp, InfoDestination, InfoSource, InfoReply）

2. **主要子消息类型**：

| 子消息 | 方向 | 用途 |
|--------|------|------|
| DATA | Writer → Reader | 发送数据或生命周期变更 |
| DataFrag | Writer → Reader | 发送分片数据 |
| HEARTBEAT | Writer → Reader | 通知可用序列号范围 |
| HeartbeatFrag | Writer → Reader | 通知可用片段范围 |
| ACKNACK | Reader → Writer | 确认/请求序列号 |
| NackFrag | Reader → Writer | 请求缺失片段 |
| GAP | Writer → Reader | 通知不可用的序列号 |
| InfoTimestamp | - | 设置后续子消息的时间戳 |
| InfoDestination | - | 修改目标 GuidPrefix |
| InfoSource | - | 修改源 GuidPrefix（中继场景）|
| InfoReply | - | 指定回复地址 |
| Pad | - | 内存对齐填充 |

#### 理解要点

- HEARTBEAT 是可靠传输的核心：让 Reader 发现丢失的数据
- HeartbeatFrag 用于大数据分片场景，是"针对分片数据的心跳"而不是"心跳被分片"
- GAP 消息区分"真正丢失"和"被过滤"（filteredCount）
- Interpreter 子消息的 Logical Interpretation 都是 None，作用体现在 Receiver 状态变化

---

### 主题 2：Key、Instance 与 instanceHandle

#### 核心概念

1. **Key**：IDL 中用 `@key` 标注的字段，用于唯一标识数据实例
2. **Instance**：同一 Topic 下由 Key 值区分的数据对象
3. **instanceHandle**：从 Key 字段计算出的哈希值，内部使用的整数句柄

#### 代码示例

```idl
/*
 * 📌 示例：车辆追踪系统
 * 🎯 目标：理解 Key 如何区分 Instance
 */
struct VehiclePosition {
    @key string vehicle_id;    // Key 字段
    float latitude;
    float longitude;
    float speed;
};

// vehicle_id = "CAR-001" → Instance 1
// vehicle_id = "CAR-002" → Instance 2
// 多次写入同一 vehicle_id 是更新同一个 Instance
```

#### 理解要点

- dispose() 只需发送 Key（标识哪个实例被删除）
- 没有 Key 的 Topic，所有数据属于同一个 Instance
- Key 可以是复合的（多个 @key 字段）

---

### 主题 3：可靠传输机制

#### 核心概念

1. **为什么需要 HEARTBEAT**：
   - UDP 不可靠，DATA 可能丢失
   - 丢失的 DATA 对 Reader 是"看不见的"
   - HEARTBEAT 告诉 Reader "我发过 SN 1-10"，让 Reader 发现缺失

2. **可靠传输流程**：
   ```
   Writer ──── DATA (SN=1,2,3) ────> Reader
   Writer ──── HEARTBEAT ──────────> Reader ("我发了 1-3")
   Writer <─── ACKNACK ────────────  Reader ("我缺 SN=2")
   Writer ──── DATA (SN=2) ────────> Reader (重传)
   ```

3. **writerSN 的作用**：
   - 唯一标识每次变更
   - 保证顺序性
   - 支持 ACK/NACK 机制

---

### 主题 4：QoS 匹配规则

#### 核心概念

1. **匹配规则**：Writer 提供的 >= Reader 请求的 才能匹配

2. **DURABILITY 等级**（从低到高）：
   - VOLATILE → TRANSIENT_LOCAL → TRANSIENT → PERSISTENT

3. **RELIABILITY 等级**（从低到高）：
   - BEST_EFFORT → RELIABLE

4. **内联 QoS（Inline QoS）**：
   - 在 DATA 子消息中直接携带的 QoS 参数
   - 用于动态变化的信息（如 dispose 状态）
   - Reader 可以请求 Writer 总是发送内联 QoS

---

### 主题 5：RTPS 行为模块概述

#### 核心概念

1. **行为模块定义**：Writer-Reader 之间消息交换的有效序列和时序约束

2. **两种参考实现**：
   - **Stateless**：Writer 不跟踪每个 Reader 状态，内存小但重传效率低
   - **Stateful**：Writer 维护 ReaderProxy，精确重传

3. **互操作性要求**：
   - 只使用标准 RTPS 消息
   - 实现 RTPS Message Receiver
   - 时序参数可配置
   - 实现 SPDP + SEDP

4. **RTPS Writer 无法控制删除**：
   - DDS DataWriter 决定何时移除 CacheChange
   - 可能在传输完成前就被删除（如 KEEP_LAST 覆盖）
   - RTPS 只能发 GAP 告知 Reader

---

## 💡 心得体会

1. **DDS 与 RTPS 的分层设计非常清晰**：DDS 管理 QoS 和应用接口，RTPS 负责传输协议，职责分明

2. **可靠传输不等于 100% 送达**：RELIABLE 只保证 HistoryCache 中的数据会可靠传输，数据可能被 QoS 策略提前删除

3. **Key 的理解关键**：Key 不是"标签"，而是字段本身的值，用于区分 Instance

4. **HEARTBEAT 的必要性**：因为丢失的消息是"看不见的"，必须有机制让 Reader 知道 Writer 发过什么

5. **QoS 匹配规则很直观**：Reader 提出需求，Writer 提供能力，能力 >= 需求才能匹配

---

## ❓ 遗留问题

1. Stateless 和 Stateful 参考实现的具体状态机
2. Writer Liveliness Protocol 的详细流程
3. Discovery 协议（SPDP/SEDP）的消息交换细节

---

## 📖 参考资料

- 文档：`DDS-RTPS.txt` 第 1734-2570 行
- 规范章节：
  - 8.3.8 RTPS Submessages
  - 8.4 Behavior Module
  - 8.4.2 Behavior Required for Interoperability

---

## 🎯 下次目标

- [ ] 继续学习 RTPS 行为模块（8.4.3 - 8.4.15）
- [ ] 学习 Stateless 和 Stateful 参考实现
- [ ] 学习 Discovery 模块（8.5）
- [ ] 动手运行 HelloWorld 示例

---

## 📊 进度更新

| 模块 | 之前 | 之后 |
|------|------|------|
| DDS 概念与架构 | ❓ | ✅ |
| RTPS 结构模块 | ❓ | ✅ |
| RTPS 消息模块 | ❓ | ✅ |
| RTPS 行为模块 | ❓ | 🔄 |
| IDL 数据类型定义 | ❓ | 🔄 |
| QoS 策略详解 | ❓ | 🔄 |
| Discovery 机制 | ❓ | 🔄 |
